# LeetCode

[TOC]



## Daily-Practice

### T1~50

**T1两数之和（Two Sum）//C++**

【思路】输入序列和目标值，输出序列中满足和为目标值的两个数的位置。

【学习】

①向量vector的使用，C++提供了一系列STL(Standard Template Library)即模板库，模板库包括容器、迭代器、空间配置器、配接器、算法、仿函数六个部分。本例中要使用的有<vector>和<map>。

【借鉴】②暴力思路很简单，注意枚举的时候三角形遍历，不要重复。基于目标值的哈希是很好的思路，可以把复杂度从O(n^2)降到O(m)。

③注意变量名和代码格式的规范性，数组索引命名当然应该用index



**T2两数相加（Add Two Numbers）//python3**

 【思路】对照题目给定的ListNode的定义方式实现

【学习】本题参考别人的代码，熟悉python的一些可以提升代码可读性的操作，简单条件的If可以写在操作后，另外多个变量可以同时赋值。

 

**T3无重复最长子序列(Longest Substring Without Repeating Characters) //C++**

【思路】这道题刷得比较艰难，在线调试没有一遍过，还是在线下编译调试了半天才发现三处问题。第一是需要注意length()函数返回的值和角标的关系：最后一个元素的角标是长度减1。平时不会在这上面犯错，但是出现循环条件判断的时候容易出错。第二处是本例有两种情况，元素直接入队、出队重复元素后入队，两种情况都要对入队元素的哈希进行修正，我一开始漏掉了后一种。第三处是直接复制粘贴导致的（发现第二个问题之后），把条件判断粘过来做赋值，直接导致赋值无效。

【思路】因为必须是连续的，所以扫描一遍就可以了，当入队的元素导致了重复时，队首元素出队直到不再重复。

 

**T4两有序数组的中位数(Median of Two Sorted Arrays) //C++**

思路来得很快，我的思路来自归并排序。这里需要先强调一下vector的用法，真的非常好用。

```
vector<int> a ;                              //声明一个int型向量a
vector<int> a(10) ;                         //声明一个初始大小为10的向量
vector<int> a(10, 1) ;                      //声明一个初始大小为10且初始值都为1的向量
vector<int> b(a) ;                           //声明并用向量a初始化向量b
vector<int> b(a.begin(), a.begin()+3) ;        //将a向量中从第0个到第2个(共3个)作为向量b的初始值
声明了向量之后，常用的操作有a.size()、a.empty()、a.clear()，还有神奇的b.swap(a)可以交换两个向量，非常好用。
```

二路归并的思路就是：设置两个指针，每次将两个指针对应的较小的数字归并，对应指针向后移动一步，如果有移动到头的指针，直接将另一路合并过来。寻找中位数的道理相同，分奇数偶数讨论即可。时间复杂度O(min(m+n))。需要注意的是leetcode不能另外开空间，它给定的数组长度是多少，就只能用这一片内存，再扩展的话会出问题。

【借鉴】本题可以优化到O(log(m+n))，思路来自两有序数组找第k小数问题。因为合并序列中必然有k-1个数小于等于k，假设这k-1个数有p个来自序列1，q个来自序列2，则必然满足如下条件：p+q=k-1；且这p+q个元素均小于第k小数。这样的话第p+1个和第q+1个数字中的较小值就是我们需要寻找的值。初始化p=q=(k-1)/2，如果第p个数小于第q个数，说明序列1中的数字都偏小了，全部舍弃，反之亦然。递归寻找第k-p或者第k-q小数，终止条件为：寻找第2小数（直接返回较小值）；p和q相等，返回后一位的较小值；较短序列到头，返回较长序列的k小数。



**T5最长回文子串(Longest Palindromic Substring) //python3**

【思路】分类讨论，串长可能是奇数/偶数，因为问题具有最优子结构（回文串去掉两头也是回文串）和无后效性，可以用DP的思路来解决，复杂度O(n^2)。需要注意的是本题还有一个分类讨论，就是串为空或者只有一个字母，一般来讲也能普适性的解决，但是实际操作的时候有可能会不对（比如串为单个字符的时候返回了空串）。

【借鉴】大致浏览了discussion里的思路，基本和我的想法一样，但是注意本题依然可以优化，https://blog.csdn.net/qq_17550379/article/details/84022674  给出了Manacher算法的优化思路，类似的道理在KMP算法中也有应用。



**T6之字转换(ZigZag Conversion) //python3**

【借鉴】本题一方面学python里面list和字符串的定义与处理，与C甚至MATLAB等语言有很大不同。另一方面展示了一个问题可以怎样从另一个角度来思考，示例本身的格式可能会极大地影响对问题的解读，所以能否跳出示例所限制的条条框框就很关键——就像这道题，在草稿纸上画一个斜的“之”字，就很清晰了。



**T7整数倒置(Reverse of Integer) //C++**

主要要注意考虑全面，用long long来储存可能越界的数值并判断越界与否，需要注意的就是-maxlongint取绝对值之后是溢出的，操作数就应该直接用64位整型。



**T8字符串转数字(String to number atoi) //python3**

【思路】打表

【注意】①python取区间是左闭右开的②corner condition优先考虑③python如果要去掉指定位置的字符，不要用replace直接置换指定字符，有可能把别的位置相同字符都置换掉了，.strip一样的道理

 

**T9回文数(Palindrome Number) //C++**

直接用T7的程序就行了，小于零直接返回0。另外可以加一句判断，如果这个数是10的整数倍，那就可以直接返回0；也可以尝试加更多剪枝语句，会略微快一点点。



**T10正则表达式匹配(Regular Expressing Matching) //python3**

【借鉴】

方法一：递归（为了方便书写，*用#代替）

本题有明显的子结构，这是递归和动归思路来源的必要条件。比如讲abb和ab#是匹配的，如何判断出来呢？首要条件是a和a匹配，然后判断bb和b#是否匹配（问题的规模缩小了），都满足之后即证明两者匹配

递归边界（为什么讨论匹配串？因为模式串长度为零的时候匹配的匹配串可能还非常长！比如''和‘a#b#c#...’是匹配的）

1. 匹配串长度为零，此时除非模式串长度也为零，否则返回false
2. 匹配串长度为一（为什么边界一定要做两个？因为匹配串的长度可能是减一也可能是减二，并且后面涉及对第二位的判断，所以必须有一个长度为一的边界），此时除非模式串长度也为一，并且匹配（相等或者匹配串是'.'）

如何拆分成子问题呢？这里干扰视线的主要是#可能会让前缀字符重复很多次，如果匹配串中没有星号那么一切问题都很简单，所以容易想到的是：

1. 如果匹配串第二位不是#，那么模式串和匹配串首位相等的情况下（或者匹配串开头'.'），可以将问题等价为子问题（二者各自去掉首位后再比较）
2. 如果匹配串的第二位是#，首先要考虑的是，会不会匹配串这前两个都是无用字符？比如讲a和a#a，他们是匹配的，前提是把a#看做a重复零次，所以要检查（s，p[2:lenp]），同时，只要首位是match的，也可以缩减为子问题（即模式串去掉首位，匹配串去掉前两位），这里肯定要写一个循环来判断，因为不知道#能去掉模式串的多少个首位。注意到，ab和.#这个妖孽的例子也是满足这样的判断方式的（变成了空串的匹配），事实上.#似乎能表达一切式子……

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        return ismatching(s,p)
def ismatching(s: str, p: str) -> bool:
    lens=len(s)
    lenp=len(p)
    if lenp==0:
        return lens==0
    if lenp==1:
        return (lens==1) and (p[0]==s[0] or p[0]=='.')
    if p[1]!="*":
        if lens==0:
            return 0
        else:
            return (s[0]==p[0] or p[0]==".") and (ismatching(s[1:lens],p[1:lenp]))
    else:
        while(len(s)>0 and (p[0]==s[0] or p[0]==".")):
            if ismatching(s,p[2:lenp]):
                return 1
            s=s[1:len(s)]
        return (ismatching(s,p[2:lenp]))
```

【思路】

方法二：DP（DP是模仿递归自己推的，感觉非常不简洁）

发现递归的思路重复计算了很多计算过的自问题，所以觉得应该可以改成递推的形式

从后向前推，设定i表示当前模式串串长度，j表示匹配串长度，dp[i,j]记录布尔值

边界条件dp[0,0]=1，dp[1,1]=最后一位是否匹配，其余j=0/1的部分全部置零

二重循环递推，讨论当前匹配串的第二位是不是*

1.  如果不是，dp[i,j]= false if not i（防止匹配串长度为零）first index match and dp[i-1,j-1]
2.  如果是，dp[i,j]=1 if dp[i,j-2]==1。模仿递归的思路，这里可初始化k为i，当当前模式串的首位和匹配串可以匹配时，k可以递减，以此模拟#重复表示多个符号的情况



**T11最能装水的容器(Container With Most Water) //C++**

本题的关键在容器的高度由短板决定，从两边向中间枚举是容易想到的，在向中间枚举的过程中比两边更低的板子是可以直接忽略的（这也是容易想到的）。

【借鉴】优化到O(n)的关键在于只用移动短板，因为对于固定的短板而言，长板的那段向短板靠近只会得到更差的结果（为什么？因为容器能装多少水是由短板决定的！两边都只能变长的情况下动长板毫无意义，所以要增加容量应该是找到两个尽可能远的长板，优化的对象永远是相对短的那一个）。所以在两边向中间枚举的过程中，只用将短板的一方向长板一方靠近，这样有可能会出现更优的解，不会遗漏最优解。

【思考】我觉得这提供了一种思维方式，贪心的过程中，可以思考怎样变化能够使得结果更好，对注定使结果更差的分支，可以直接剪掉，故可以思考怎样变化注定使结果变差。

 

**T12阿拉伯数字转罗马数字(Integer to Roman) //C++**

本题的关键麻烦在于4、9、40等这些特殊数字，如果讨论来解决非常麻烦。

【借鉴】直接打表，干脆将所有特殊数字打表，就迎刃而解。

 

**T13罗马数字转阿拉伯数字(Roman to Integer) //C++**

同样是打表，这次思路就很清楚，先对比两个连在一起的，再对比单字符的就可以了。



**T14最长公共前缀(Longgest Common Prefix) //python3**

找到最短的那个，从头开始逐字符判断即可

【注意】本题是典型的反面判据：为了代码的简单性，我设置的是一旦发现不同就退出，由于是二重循环，需要设置一个flag变量break两次，外层的break一定要写在内层循环之后，否则很容易出现问题。



**T15三数之和(3 Sum) //python3**

【思路】由于样例中给出的三元组都是有序的，所以显然应该先对输入序列排序。本题至少应该优化到N^2，所以排序的复杂度可以不计。设置三个指针变量，i、j、k，代表三个数在数组中位置，如果i从开始向末端移动，那么j从i+1的位置向末端移动，由于nums是有序的，对同一个i而言，k只需要从nums的末端扫描到j+1的位置即可。
优化的关键在于，如果nums[i]和num[i-1]一样的话，直接continue就好了，因为如果nums[i]==nums[i-1]，由num[i]计算出的结果必然是num[i-1]的子集。



**T16三数之和最近(3 Sum Closest) //python3**

【思路】和上面一模一样，计算误差，对每个i，k只向一个方向移动，移动到对当前j来说误差最小的位置。如果对j来说这个k是最好的，那么对j+1来说，更好的k不可能向右移动！因为向右只会让误差更大。



**T17电话号码字母组合(Letter Combinations of a Phone number) //python3**

【思路】检讨，我第一反应居然是递归。这根本没有必要递归的，递归是自己浪费系统堆栈。自己拿一个list把结果存起来，从1个字母推到n个字母就好了，每一步把上一步的结果从list里面删掉

【注意】如果要用remove删，删len（上次的len）次ans[0]就行了，千万别删每次去删ans[j]，依次执行会出问题的



**T18四数之和(4 Sum) //python3**

【思路】照搬3数和的思路，马马虎虎凑了个N三方的程序怼过去了，还不错，如果按有序性break的话，如果target正常其实勉强算常数比较大的N平方？

【借鉴】其实计算并储存两数之和然后用字典检索就好了，可以优化到N平方的，不过我懒，不想写这个代码了



**T19去除链表倒数N位数(Remove Nth Node from End of List) //python3**

【思路】模拟

【注意】要细心，设计链表的题，注意头结点的处理。另外corner conditon：输入的链表只有一个元素怎么办？



**T20有效括号(Valid Parentheses) //python3**

【思路】栈

【注意】空栈单独判断



**T21合并有序链表(Merge Two Sorted Lists) //python3**

【思路】模拟

【注意】注意新结点要调用构造函数生成



**T22生产括号(Generate Parenthese) //python3**

【思路】栈混洗，Catalan数，递归生成即可

【注意】我尝试了将ans放在全局变量，发现它似乎会随着测试数据的更迭而变化（append的话会把上一个数据的结果也保存下来，所以最好不要放全局）。

【补充】这和C++的类与对象是一样的。LeetCode的题解调用的是一个类为Solution的对象中的特定函数，所以不要把变量或者结果定义为全局变量（如果非要的话，在被调用函数的内部初始化）。如果把变量或结果定义为类的一个属性，也要注意在调用的那个函数的时候初始化（我没有试过构造函数，也许可以吧）。

【补充思路】反正是遍历最终ans树的所有叶子结点，广搜当然也可以，第二遍做是在每日一题，写了一遍广搜。从实际执行结果来看，效率不如深搜，可能原因是list的插入和保存时间效率不高，不如系统栈的实现。



**T23合并k个排序链表 //python3**

【思路】

解法1：分治，按归并排序的思路来是最容易想到的办法，基础操作是双链表的合并。

解法2：优先队列，将k个链表的表头元素维护成一个小头堆，堆顶出队，对应链表的next入队。注意python3有queue模块，这个代码是从力扣的官方解答中拔出来的，当然我做了小的改动。python原版本引用模块是Queue，注意Q大写，另外加入优先队列的元组中可以有链表。python3好像不能加入含有链表的元组，所以我改成了链表序号k。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

from queue import PriorityQueue

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if lists == []:
            return []
        head = point = ListNode(0)
        q = PriorityQueue()
        for k in range(len(lists)):
            if lists[k]:
                q.put((lists[k].val, k))
        while not q.empty():
            val, num = q.get()
            point.next = ListNode(val)
            point = point.next
            hh = lists[num]
            tmp = hh.next
            lists[num] = tmp
            if lists[num]:
                q.put((lists[num].val, num))
        return head.next
```



**T24 两两交换链表中的节点**

【思路】考察对链表和指针的理解，python的链表相对C而言人性化了很多，操作起来还是比较方便的。



**T25 k个一组翻转链表**

【思路1】

模仿上一题，储存头结点、下一个头结点，从后向前依次将结点指向上一个结点，时间复杂度O(nk)，空降复杂度O(1)，完全符合要求，虽然时间复杂度略高，但只用了3个临时结点和一个哨兵结点，空间复杂度为常数

【借鉴思路2】

用栈来储存结点，依次入队后出队反转，注意头结点之间的衔接即可。时间复杂度O(n)，空间复杂度O(k)，不过，这种解法其实并不符合题意，空间复杂度过高。

【借鉴思路3】

和思路1一样，不过特殊之处在于，其实思路1翻转链表的方式挺蠢的。翻转链表有非常简单的方式（莫名感觉像辗转相除或者原地操作的斐波那契？）：

```java
	public ListNode reverseList(ListNode head) {
		ListNode pre = null;
		ListNode cur = head;
		ListNode tmp = null;
		while(cur!=null) {
			tmp = cur.next;
			cur.next = pre;
			pre = cur;
			cur = tmp;
		}
		return pre;
	}
```



**T26 有序列表去重(Remove Duplicates from Sorted Array) //python3**

【思路】模拟

【注意】时刻注意下表是否越界



**T27 去除元素(Remove Element) //python3**

【思路】模拟

【注意】时刻注意下表是否越界



**T28实现 strStr()(Inplement strStr()) //python3**

【思路】模拟，人生苦短我用python，python的字符串集成了.find函数，重载了查找字符串的功能！



**T29两数相除(Divide Two Intergers) //python3**

【批评】本题相当无趣，主要是负数情况的讨论，非常boring



**T31下一个排列 //python3**

这题我写得浑身难受，要注意的地方有点多，它又要求原地操作，浑身难受。

【思路】下一个排列是什么？是先找到包含末尾的连续的下降序列，然后将下降序列的前一个数字，和下降序列中刚好比它大的数字，进行交换，交换后对原下降序列位置上的所有数字逆序。

【注意】何谓下降序列？这是一个不要求严格下降的序列，等于也是可以的。但是交换的时候，要求严格大于。

【思考】关于这个机理需要进一步思考，为什么这样能得到字典序恰好更大一点点的序列？



**T32 最长有效括号 //python3**

【借鉴】动态规划，首先注意它必须是连续的括号，如果不要是连续括号的话，其实非常简单。连续有效括号的动规思路如下：

设定dp[i]表示以第i位结尾（必须包含i）的最长有效括号，初始化所有左括号位置的dp为零。【分类讨论】如果是右括号，'))'和'()'的形式分开讨论，'))'要前推上一个右括号的最长有效括号数，看看前面是不是'('，如果是，在上一个基础上加2。'()'就简单了，在前两个基础上加2就好了。



**T33 搜索旋转排序数组 //python3**

【思路】因为之前做过了旋转排序数组旋转点（对升序序列而言是最小值）查找的程序，所以本题思路非常明了，先找出旋转点，然后分段进行二分查找

【补记】附上的代码写复杂了，因为仅从大小就可以判断target在哪一段中。



**T34 在排序数组中查找元素的第一个和最后一个位置 //python3**

【思路】二分查找变形，关键在二分的时候大于小于号带不带等号，对于一般查找，等于即可返回。对这种问题，找左边开头数字的话，如果target<=nums[mid]返回左边，否则返回右边。找右边开头数字的话，如果target>=nums[mid]返回右边，否则返回左边。

【注意】现在写此类代码已经形成习惯，如果r-l小于一定值直接使用枚举法查找，理论上来说可以提升性能，也能避免递归边界是l==r还是l==r-1的问题。



**T35 寻找插入位置(Search Insert Position) //python3**

【思路】分治法，cornor condition是输入空列表



**T36 有效的数独 //python3**

【思路】纯模拟，之前在CodeWar上做过。



**T37 解数独 //python3**

【反思】我现在写一个回溯如此吃力 = = 是该正视自己的水平了，太菜了

1. 第一次犯错误，是在擦除的时候，这个时候不能返回False的，要让循环继续跑。写回溯一定要思路清晰。然后就是，先判断再修改，我一开始直接改map，如果不行又忘了擦，我是怎么想的呢：如果不行会被下一个覆盖，如果都不行会调用上一个。但是这个位置被最后一次循环填了，又没有调用下一层，没地方擦它，就出问题了。
2. 第二次改对了，提交却超时，为什么呢？因为判断是否合理写得太蠢了。每次填入一个数字，并不需要对全体数独都判断一下，只需要判断填入的这一行、一列、一块就行了，其他的肯定都是对的，重复判断必然超时。



**T38 数数(Count and Say) //python3**

【思路】递推，能不用递归尽量不用，想了半天发现实在是没有使用递归的必要性。



**T39 组合之和(Combination Sum) //python3**

【思路】本题子结构十分明显，最自然也最合理的思路只能是递归。

【注意】

1. 像这道题，为了节约内存，我已经尽可能地减少递归调用的参数了，需要注意的是（再次强调），保存在对象初始化时的ans，那个ans在被调用的类函数中要做初始化，不然每个样例的结果会在里面累加。。。
2. append实在是一个不太好用的函数，说实话我写python到现在觉得方便是方便，但这功能确实有点冗余（对于list的append函数来讲），因为append是对自身的一个过程，在递归调用的时候经常把list.append()当成一个列表（然而其实返回值是None），还不如直接list+[new element]来得舒服。。。

【思考】我这个解法完全没有优化也干掉了82%/100％，因为排了序，所以查找的时候可以用二分查找的，还可以优化。内存也是，可以思考能不能不把历史存在递归的参数中，回溯得到结果可以吗？



**T40组合之和2(Combination Sum 2) //python3**

【思路】想把上一题的代码直接搬过来。思考了一下发现肯定不行，因为如果有重复元素的话，肯定会出现重复组合。所以最开始的想法是，照搬上题代码，加一个hash。但是对列表进行hash显得有点蠢（set本身是基于dict的，也不支持对list这种“可变”结构进行hash），对tuple哈希倒是可以，总觉得背离了题目的本意，如果数据给一百万个同样的数字，会浪费大量的时间去判重。

​        典型的错误优化思路就是直接把输入序列去重，转换为set，然后每次向下递归的时候，可以重复使用元素。（这个思路显然是不行的，因为元素的个数是一个很重要的信息，不可能丢掉的，使用次数会超过上限）

​        所以最终还是用第一个想法，老老实实转成tuple放进set里面hash一下去重。效率确实不高，23％/100％

【学习】因为这道题我详细了解了一下python里面tuple、set、list、dict的关系，发现后三者是不能放进set的，因为他们的内容是可变的，而tuple的内容是不可变的（就像constant一样），不可变才是hashable的。



**T41首个消失的正整数(First Missing Positive) //python3**

【思路】这题感觉没办法取巧，只能从1开始尝试，关键是判断是否存在的时候hash一下。python的set查询是用了dict的，也就将它本来就做了很好的hash（用的是red-black tree)。那么直接翻译就行了

【疑问】C++STL应该也是集成了set或者dict的？那这题为什么算hard？我寻思就是自己手写hash也并不困难啊。而且在discussion里面我居然发现有人，，，直接用list写了个N^2的也过了？python的list查询应该是没有用红黑树吧，，，难道python3改了？不明白。



**T43 字符串相乘**

【思路】大整数乘法，这题让我感觉我确实老了，写个高精度错了两遍。第一遍没考虑一个乘数为零的情况下会输出大量前导零，第二遍debug的时候没考虑零作为乘数结果也是零（如果去零的话会全部抹掉），同时每个数字应该在大于9的情况下模十，而不是大于10，，，



**T44 通配符匹配 //python3**

【思路】动规，缩减问题规模。本题出现"?"的情况好处理，它可以代替任何一个字符，那么就相当于模式串与匹配串的字符相同。关键在处理出现“*”的情况，它有可能代表任意长的字符串，故而要和检查p[j]和s[k]其中k取0到

i+1的所有模式串之间的关系，只要其中有为真的，都可以算真，因为“*”可以干掉模式串之后的所有字符。

【注意】由于外周循环是双重的，如果遇到“*”就枚举之前的情况，可能退化到O(N^3)，这是不能接受的。所以另外开一个数组，记录到当前匹配串位置为止，每一个模式串位置对应的下标上有没有出现过为真的情况，一旦出现过，匹配串下一个出现了星号就可以直接判定为真。

【借鉴】本题可以用贪心



**T45 跳跃游戏二 //python3**

【思路】贪心，第k步的区间是l~r，然后第k+1步的区间是r+1~max(r+1,i+nums[i])，其中i~[l,r]，只要这个区间越过了（包含）len(nums)-1，即为当前最优步数。

【注意】本题还蛮简单的，注意一下cornor condition即可，输入为空、长度为1都是直接返回0的。



**T46排列(Permutations) //python3**

【思路】当然是递归，全排列应该只能用递归做，毕竟自带n阶乘的复杂度。让我觉得困难的地方在于定义什么参数？用什么方法来储存答案？

【注意】python的许多自带函数都是对自身进行操作的（准确来讲叫过程？），很多时候需要不改变自身而幅值给别人的话需要注意

【发现】python的OOP原理和C++几乎一模一样，像这道题，我发现在Solution类里定义一个变量，然后用加一个初始化函数，在一个类里都能用，应该是默认public的吧。

【更新】每日一题重复了，用回溯重写一遍，效率反而变低了？不过倒是熟悉了python变量拷贝的问题



**T47排列二(Permutations 2) //python3**

【思路】本着不重复造轮子的原则把上道题的代码粘贴过来，循环的时候注意重复的元素不进行递归调用，定义一个集合来判别重复即可。



**T48旋转图像(Rotate Image) //python3**

【思路】四个数的置换，本题强调原地操作，还是很有意思的。



**T49相同字母异序词(Group Anagrams) //python3**

【思路】Hash，这题我尝试了自己的想法，卡时间过：将字母的ASCII值加上一个大质数，然后相乘，作为哈希值。如果不加这个大质数，最后一个点会过不掉，因为26个字母的ASCII值并不互质，总是会出一些问题。

【借鉴】别人的代码，正规哈希

```python
class Solution(object):

    def groupAnagrams(self, strs):
        """ 
        :type strs: List[str]
        :rtype: List[List[str]]
        """ 

        anagram_hash = {}
        anagram_list = []

        for s in strs: 
            if "".join(sorted(s)) in anagram_hash:
                anagram_hash["".join(sorted(s))].append(s)
            else:
                anagram_hash["".join(sorted(s))] = []
                anagram_hash["".join(sorted(s))].append(s)

        for k, v in anagram_hash.items(): 
            anagram_list.append(v)

        return anagram_list
```



**T50快速幂(Pow(x,n)) //python3**

【思路】英语翻译

【启示】人生苦短，我用python（真就拒绝重复造轮子呗）



### T50~100

**T51 N皇后 //python3**

【思路】回溯，太经典了



**T52 N皇后2 //python3**

【思路】同上



**T53 最大子序和 //python3**

【思路】

解法1：类似于动规，递推过去就好，有明显的子结构，O(n)

解法2：分治，O(log(n))，不断二分，合并的时候要判断两个分段的最大子序是不是连在一起的。如果不是，还要分类讨论（**没有写代码**）



**T54 螺旋矩阵 //python3**

【思路】归纳分析+比较复杂的模拟操作，设置四个方向向量，用模运算来实现周期为4的循环，转到无路可走的时候退出。



**T55 跳跃游戏 //python3**

【思路】不知道为什么，跳跃游戏2反而在前面，但是两道题本质是一样的，贪心思路可以完美解决。



**T56 合并区间 //python3**

【思路】对区间进行排序，然后依次合并。由于排过序，所以只需要判断当前最后一个已经合并的区间，右端是否落在未合并区间左侧之右，如果是，说明重叠，进行合并，合并左侧为已经合并区间的左侧，右侧为两个区间右侧的较大值。



**T58 最后一个单词的长度 //python3**

【思路】模拟



**T62 不同路径 //python3**

【思路】动态规划

【借鉴】这题可以排列组合！原谅我竟然五分钟没有想出数学规律



**T63 不同路径 二//python3**

【思路】动态规划，只能从左边或者上边过来，所以可以进行转移。

【借鉴】滚动数组压缩，不仅是空间上的，时间常数也可以缩减不少。



**T64 最小路径和 //python3**

【思路】最简单的动规了，模仿上面两个例子也很容易能想到优化到1维的方法。



**T66 加一 //python3**

【思路】高精度的基本操作，注意首位的进位。



**T67 二进制求和 //python3**

【思路】模拟

【借鉴】人生苦短我用python

```python
class Solution:
    def addBinary(self, a, b) -> str:
        return '{0:b}'.format(int(a, 2) + int(b, 2))
```



**T69 x的平方根**

【思路】不太想直接开根号，所以我用的是牛顿拉夫逊迭代，然后注意了一下量化误差。

【注意】这题的题解区非常精彩，八仙过海各显神通。



**T70 爬楼梯**

【思路】两步递推，最优解法应该是矩阵快速幂了。不过从提交结果来看也不算快，应该是数据量不大。



**T90 子集 Ⅱ //python3**

【思路】我仔细想了想，这种题不需要递归，循环就能破。如果不给输入数据的范围，可能需要考虑递归，但counter应该也可以满足要求。

【注意】在写这道题的时候我才开始认真考虑，python里面关于列表的深拷贝应该怎么操作，a = b[:]这种有点讨巧的写法确实666。



**T93 复原IP地址**

【思路】因为分割层数确定且小，所以本题可以循环。当然，循环的时间效率一定不如回溯，不过空间效率要好得多。本题用循环+回溯实现了，算是比较好的练习。

【注意】注意IP地址本身的格式，每一位可以是零，但是每一位不能包含前导零



**T95 不同的二叉搜索树二**

【借鉴】这题上来属实把我整懵了，有下面T96做铺垫，递归是容易想到的，不过之前都是生成一棵树，这里要生成森林，返回应该设成集合。

【思考】这种递归中套循环的最终返回集合的，除非确定一次循环生成几个元素，不然就直接对集合递归了。



**T96 不同的二叉搜索树**

【借鉴】左子树从0到n，右子树从n到0，这就是卡特兰数。



**T97 交错字符串**

【思路】二维动规不难

【想法】如果用一维数组滚动，处理情况和二维的简单情况不同，注意看Conclusion中。



**T98 验证二叉搜索树**

【借鉴】BST判断应该最好是用中序遍历，这里写在总结里面了，它实现中序遍历的方法还是很骚气的（今天写T99，时隔几个月回头看，我giao，这么正常的中序遍历写法，我当时怎么会觉得骚气？我当时是得有多菜？）



**T99 恢复二叉搜索树**

【思路】中序遍历，朴素中序遍历。我没按照它要求的原地操作来，不想搞太复杂

【注意】这题的第一个注意事项在于，如果一个有序递增数组，两个数之间调换了位置，怎么找出这两个数？第一个数可以从前向后找，第二个数可以从后向前找。如果只遍历一遍，第一个数字应该是满足逆序关系的第一对数字的第一个数字，第二个数应该是满足逆序关系的最后一对的第二个数字。

【借鉴】morris中序遍历，这个在今天的我看来依然是骚操作。它按照中序遍历的思想，将前置元素链接到根节点，遍历完左子树之后，再顺着链接回到根节点，以避免了存栈弹栈的操作浪费空间。回来之后过河拆桥，将链接删除。



**T100 相同的树**

【思路】递归



### T100~300

**T102 二叉树的层序遍历 //python3**

【思路】类似于一个广搜的过程，直接BFS即可



**T104 二叉树的最大深度 //python3**

【思路】模拟，深度优先遍历



**T108 将有序数组转换为二叉搜索树 //python3**

【思路】要求是平衡的，所以指定中点作为根节点即可。按照题目意思递归实现。



**T112 路径总和 //python3**

【思路】直接暴搜



**T118 杨辉三角 //python3**

【思路】递推就好



**T119 杨辉三角Ⅱ //python3**

【思路】只需要一个数组即可

【注意】原地操作注意覆盖的问题



**T120 三角形最小路径和**

【思路】经典动规

【注意】用滚动数组优化的时候要注意讨论边界，它两边是要单独考虑的，杨辉三角的最外层只能从头上来。



**T121 买卖股票的最佳时机 //python3**

【思路】本题虽然简单，但它确确实实有动态规划的思想在里面。倒着往回记录一遍当前时间抛售后可以享受的最高售价，然后正着扫描一遍就行了（其实不用正着扫描，倒着推的时候就可以做了，补记）



**T128 最长连续序列 //python3**

【思路】如此朴素的哈希题不多见了



**T130 被围绕的区域 //python3**

【思路】本题的关键在于条件的转换，那么既然是要把被包围的区域同化，只需要把不被包围的区域标记即可，用另一个数组记录是否曾经到访过该区域，从边界开始向内寻找4领域连通块即可。

【想法】之前我找连通块都是用广搜的，现在看起来深搜也完全能够胜任，而且甚至还快一点？



**T133 克隆图 //python3**

【思路】写在Conclusion中了，这题的官方代码无论是拷贝还是哈希写得都非常好。



**T136 只出现一次的数字 //python3**

【思路】异或，这题的延伸版是面试题56-1



**T141 环形链表 //python3**

【思路】快慢指针，龟兔赛跑



**T151 翻转字符串里的单词 //python3**

【思路】s.split()，s.reverse()，''.join(s)。军体拳三连。



**T153 寻找旋转排序数组中的最小值 //python3**

【思路】二分法，由于没有重复元素，中间值大于最右值的话说明在右边，中间值小于最右值的话说明在左边。



**T154 寻找旋转排序数组中的最小值 //python3**

【思路】和上道题一样，但是由于元素可重复，中间值有可能等于右边，此时无法判断最小值在哪边。那怎么办？一种思路是两边分别再二分，然后取较小值。我的思路比较暴力，如果中间的等于右边，那说明至少有一半以上的相同元素，这种极端情况已经接近O(N)了，既然这样，遇到这种情况直接暴搜就好了。



**T155 最小栈 //python3**

【思路】注意，在初始化函数里要这样定义：

```python
def __init__(self):
    self.stack = []
```

这个地方self指针要带上，不然类中其他成员不认识这个stack。别的没什么好说的，注意list.pop()返回的是pop的值，同时也会把list列表里面的元素抹去。



**T167 两数之和二 - 输入有序数组 //python3**

【思路】双指针典型例题，快慢指针



**T169 多数元素 //python3**

【思路】模拟



**T174 地下城游戏 //python3**

【借鉴】如果按照正常思路顺推，会发现结果与最后一个点的值有关，不满足无后效性原则。反过来推则可以满足无后效性原则。



**T198 打家劫舍 //python3**

【思路】由于每日一题的存在，我先做的面试题17.16按摩师（这名字怎么这么sq），跟本题一模一样。



**T199 二叉树的右视图 //python3**

【思路】广度优先搜索。也就是层序遍历，然后返回每层的最右侧值即可

【借鉴】思路有点僵化，可以右子结点先入队，然后就不用算长度了



**T200 岛屿数量 //python3**

【思路】广搜入门题。

【注意】本题我犯了两次错误。本来说起来广搜写起来应该很熟练了才对，结果总是犯奇怪的错误。首先是是注意输入格式，本题输入的是字符列表，不是数字；然后就是循环变量的问题，python没有提示循环内部已经改变循环变量的，我特别喜欢用dx和dy这样的4/8位循环来表示城际/8块距离，内循环写的时候注意有没有用外循环的变量。



**T201 数字范围按位与 //python3**

【思路】本题的算法是我自己想出来的，跟官方题解有所不同，但时间效率几乎一样高。可以统计每一个bit位跨几位后会翻转，计算一下最小周期，然后，只需要对区间的一头一尾做按位与，然后把一定是零的部分bit位置零即可。uan

```python
#t201 数字范围按位与 my own methods
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        x = n-m
        ans = m&n
        cnt = 0
        while x>0:
            x = x >> 1
            ans = ans >> 1
            cnt += 1
        ans = ans << cnt
        return ans
```

```python
#t201 数字范围按位与 official solution
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while n>m:
            n = n&(n-1)
        return n
```

**T202 快乐数 //python3**

【思路】循环判断，模拟

【借鉴】这道题最有意思的地方在于如何判断判断多少次，它很重要的一个思维是判断转化的收敛性，看样例很容易就会觉得，平方和是越来越大的。但其实对大数来讲，它各位平方和会收缩到一个非常小的数字上。

【注意】python的set()真的是强了，这题我设想了一个比较巧妙的hashmap，并针对特定情况进行了优化，结果却是毫无变化。



**T207 课程表//python3**

【思路】拓扑排序，本题的本质是判断原给定图是否是一个有向无环图（DAG），采用拓扑排序的方式可以实现这一点。具体操作方法为：维护一个入度序列，分别储存入度为i的点集合。入度为0的点优先出队，出队的同时将这些点指向的点入度-1，如果减到0即可入队。维护此队列直到没有入度为零的点，此时如果所有的点都被遍历完了，说明是DAG，反之不是。

【说明】上面这种出队顺序，就是拓扑排序。出队的顺序实际上是选修课程的一种方法，前后依存关系一定满足。



**T216 组合总和 三 //python3**

【思路】回溯+剪枝，从小到大开始DFS即可

【注意】对这种需要列出所有结果的列表返回值，注意对象的浅拷贝和深拷贝的问题。



**T221 最大正方形 //python3**

【思路】很容易想到动态规划，以右下角为记录点

【借鉴】它的动态方程还是很巧妙的，dp[i,j] = min(dp[i,j-1],dp[i-1,j],dp[i-1,j-1])+1

【注意】cornor condition，又被这个坑了，如果只有一个数或者一行、一列或者除这些之外都是零，动规实际上不推，这时候该输出什么就要看情况了。所以一开始就要判断第一行第一列有没有1，有1的话MAX设置成1。



**T226 翻转二叉树 //python3**

【思路】直接的递归，从下往上翻转和从上往下翻转都是可以的



**T237 删除链表中的节点 //python3**

【思路】链表的基本操作，由于题目保证了不会是尾节点，且不需要深度拷贝，故而直接舍弃后继节点，将其值拷贝到当前节点，并将Next跳一位指走即可（虽然这样写没有回收，挺浪费的）



**T239 滑动窗口最大值 //python3**

【借鉴】本题是经典的轮子题，底层轮子是双向队列如何实现

这里的应用也可以叫单调队列，它本身维护一个单调的数列，入队数列从队尾到队首依次比较，小数字按次序出队，然后新元素入队。如果队首最大值元素已经不在滑动窗口内，则出队。注意讨论队列是否为空的情况



**T283 移动零 //python3**

【思路与借鉴】见conclusion，经典双指针



**T300 最长上升子序列 //python3**

【思路】DP经典思路，以dp[i]记录以第i位结尾（必须包含第i位）的最长子序列长度，那么显然，需要枚举N^2次，找到其之前小于第i位数字结尾的所有dp中最大的那个，加1就是dp[i]

【想法】DP的效率肯定不是最优的，本题有更优的分治算法。另外注意对比这种“子序列”和连续子序列的区别



### T300~600

### T309 买卖股票的最佳时机

**T312 戳气球//python3**

【思考】本题并不难想到是动态规划，其实感觉类似合并石子。回溯的思路是容易的，如果思考回溯过程中不该重复计算的点，就很容易想到动态规划的思路了。

【借鉴】难点在于，设开区间，同时标定循环的顺序。本题探索循环顺序的方法写在conclusion中。



### **T315 计算右侧小于当前元素的个数//python3**





**T322 零钱兑换 //python3**

【思路】第一想法递归（毕竟这题刚学递归的时候我做过），然后就陷入了减法的坑，调了半天都是超时。因为硬币可以用很多次，所以应该用乘法来递归，其实感觉借鉴了动规的思路。

【借鉴】不超时的关键在剪枝，有点像分支界定法的优化思路，先计算可能的最大值，然后凡是当前递归下去要超过当前最大值的都剪掉，更新最大值。

本题可以使用动态规划求解，可以参考LeetCode官方文档。我能想到的思路是借鉴完全背包，理论上来说可以用一维动规求解。



**T329 矩阵中的最长递增路径 //python3**

【思路】DFS是不可能的，递推+贪婪式更新，效率很低但是刚好够用



**T343 整数拆分 //python3**

【思路】本题的子结构和无后效性是很明显的，动态规划。关键在于，有些数的结果可能比其本身要小，那么在拆分的时候，乘子应该是max(dp[i],i)

【借鉴】可以优化，从数学的角度不难想到，其实最优方案当中只包含1,2,3三个数字。4可有可无。



**T344 反转字符串 //python3**

【思路】人生苦短



**T349 两个数组的交集//python3**

【思路】哈希表，简单的优化还是要做的，尽量减少查询的次数



**T350 两个数组的交集二 //python3**

【思路】模拟



**T365 水壶问题 //python3**

【思路】这道题我非常熟悉，一是因为以前做过，二是因为太阁立志传5的医学小游戏就是类似的模式。不过本题的环境不同于那个小游戏，因为如果min(x,y)<z，返回的结果一定是False。换言之，最终的结果不是一个单独可容纳水的“壶”，而是一个定量，这个定量必须用给定的两个筒做出来。

然后就是数学问题了，本题可以建模为mx+ny = z，求解这个方程。这是一个两变量的丢番图方程，是否有解可以用裴蜀定理（贝祖定理）来解决。结果是z%(gcd(x,y))==0。特别来说，mx+ny=1，当且仅当x和y互素时有解（等价关系，充分必要条件）。后面贴上我惯用的GCD函数，感觉还是比较简洁的。

【借鉴】当然，搜索可以解决一切问题，本题可以用深度/广度优先搜索解决。

```python
def gcd(a:int,b:int)->int:
	return gcd(b,a%b) if b else a
```



**T378 有序矩阵中第K小的元素**

【思路】优先队列，因为一个数一定小于其右边和下边的数字，所以在它出队之前，它的右边和下边都不需要入队。当它出队后，再将一定比它大的数字入队。如此一来，从左上角开始入队，维护一个优先队列，第k个出队的就是我们要找的值。

【借鉴】这里有二分查找的方法，可以对矩阵进行划分，非常秀。



**T392 判断子序列**

【思路】模拟



**T405** **数字转换为十六进制数** **//python3**

​    打表，位运算。不过这题有点奇怪的地方在于，int储存类型应该是自动完成补码运算的，负数与正数的处理手段应当是相同的。但是python里面这个右移似乎在碰到符号位的时候会出一点小毛病，所以我只能将32比特全部转换完，再去掉左侧连续零。它这个字符串函数可以说是非常强大了，s.strip（<char>）可以去掉两端指定字符，lstrip和rstrip可以去掉左端和右端指定字符，非常好用。



**T409 最长回文子串 //python3**

本题在借鉴了错误样例检测的情况下思路依然错了两次。

犯了很多想当然的错误。由于可以从字符串中随意挑选字符，所以尽可能多地每种字符都拿偶数个。对数量为奇数个的字符，最多的放中间，较少的减一个拿偶数个出来即可。当然如果没有奇数个的，直接求和就行了。

所以最终的公式应该是：sum(count_even+count_odd)-if(num_odd>0)



**T424 替换后的最长重复字符 //python3**

【借鉴】滑动窗口

【注意】既然我们寻找的是最长的窗口，那么，什么时候该移动呢？是当前窗口长度大于当前窗口内字符数目最大值+k。那如果这个最大值没有更新，就不需要判断！所以我们需要维护的仅仅是一个“历史”最大值而已，而没有必要每次都去统计最大值是多少，只有当出现”史高“最大值，也就是最大值变大了的时候才需要被考虑。

至于最大值变小，你管他变成多少呢！



**T445 两数相加2 //python3**

【思路】链表转高精度，高精度相加，高精度转链表。python3集成了高精度，就非常任性了。



**T448 找到所有数组中消失的数字 //python3**

【思路】这题我觉得出得不错，要是能限制下内存的使用就更绝了。

它其实是考察哈希的基本思想，利用位置信息做哈希操作，由于有N个位置，我们把出现的元素映射到位置上，对应位置的数值加N，为了消除累加的影响，调用位置的时候应当是信息对N取余。最后我们遍历数组，哪个位置对应的元素比N小输出哪个就好了

【注意】注意给定的是1~N的范围，取余应该映射到0~N-1

 

**T461** **汉明距离** **//python3**

^按位异或，&按位与，>>右移，<<左移



**T480 滑动窗口中位数 //python3**

【借鉴】中位数经典算法永流传，维护两个数目差不多的堆，大的一半数字维护成小头堆，小的一半维护成大头堆，那中位数必然可以用两个堆顶做出来。

【注意】主要就是滑动出去的元素怎么擦除，这里用的是延迟去除法，也就是维护一个哈希表，标记在堆中但是应该不在堆中的元素，到堆顶的时候给它踢出去（毕竟非顶的元素不好踢）。



**T485 最大的连续1的个数 //python3**

【思路】本题考查的是中文翻译为代码



**T498 对角线遍历 //python3**

【思路】模拟，注意分类讨论

【借鉴】除了模拟，其实可以从对角线的特征下手，毕竟同一对角线元素横纵坐标相加和相等，这个更加本质，代码会简洁不少。



**T509 斐波那契数**

模拟，当然了本题最快的方法是打表。



**T541 反转字符串 Ⅱ**

模拟，这道题如果直接用反向切片做，需要注意的地方还蛮多的。



**T542 01矩阵 //python3**

【思路】我的思路应该来自dijkstra，本质上也是一种贪心，即：每次每个点“检查”自己周围四个点的值有没有变动，如果有的话就更新自己的状态。直到有一轮，所有的点都没有更新自己的状态，那么结束。

【思考】其实想想看这样的算法效率确实算不得高，虽然内存完爆所有提交的代码。除非牺牲内存，另外开一片空间记录上一次所有变动的点的坐标，然后下次直接变动其四周所有点，这样可以节省不少时间。

【借鉴】广搜当然可以啦，弄一个超级源点出来，广搜一开始入队全部的零点。动规也是可以的！因为广搜会重复搜，其实只需要考虑向右+向下和向左+向上即可，因为最短城际距离必然有两条（如果是直线，看做两条重合的），这个好理解。



**T543 二叉树的直径 //python3**

【思路】等于左子树高度和右子树高度之和+2，我是回溯实现的，节省了不少时间（代价是内存仅仅超过了百分之10，多用了3Mb吧，以前很少出现这种情况，毕竟C出身写过板子的应该在用内存上都非常扣）。当然本题可以直接对每个节点都去计算左子树和右子树的高度之和，但感觉这样做的话意义不大。



**T547 省份数量 //python3**

【思路】没啥好说的，裸并查集



**T557 反转字符串三 //python3**

【思路】模拟



**T561 数组拆分一 //python3**

【思路】贪心



**T566 重塑矩阵 //python3**

【思路】关于列表在python中是如何储存的这件事.mp4



**T567 字符串的排列 //python3**

【思路】不多写了，水哈希





### T600~1000

**T637 二叉树的层平均值 //python3**

【思路】层序遍历



**T643 子数组最大平均数Ⅰ //python3**

【思路】sliding window，或者说模拟吧



**T657** **机器人能否回到原点** **//python3**

没啥好说的，s.count(<char>)是真的好用。



**T665 非递减数列 //python3**

【思路】一开始想着，只有一个相邻逆序对作为判断条件，但6734这种特例显然是不满足的。想了一下，需要满足的条件应该是这样的：要么单调；要么仅仅出现一个不单调点，且附近4个点不能形成“平行四边形”，即出现间隔的两个逆序对，那样肯定也是调整不过来的。不够四个点的放过，连续下降两次的打死。

【注意】即使是简单题，也可能出现比较复杂的情况。



**T679 24点游戏 //python3**

【思路】搜索，这题搜索空间不大，但是有很多需要注意的地方

【注意】一是回溯经常会碰到的一些情况，状态的擦除等等。而是注意本题会出现除零的可能性，一旦遇到除零，应该直接跳过。



**T695 岛屿的最大面积 //python3**

英语翻译题。一般来讲，广度优先搜索或者深搜，直接拓展开来求最大连通块。这倒是让我想到了写扫雷的逻辑的时候做的事情。

【2020/8/16补】连通块这种做了不少了，图小的时候深搜似乎快一点



**T696 计数二进制子串 //python3**

【思路】关键在于条件转化，转化为两个相邻的同0同1子串长度的最小值，然后求和即可。



**T697 数组的度 //python3**

【思路】这题标的是简单，但还是有点麻烦。

先找到众数，然后预处理数组，一次遍历找到各数的开始位置和结束位置（哈希表优化），最后在计算最长的，，，，

这哪是简单啊



**T703 数据流中的第K大元素 //python3**

【思路】堆，只需要保留较大的K个元素即可



**T718 最长重复子数组//python3**

【思路】这题还是蛮简单的，思路上是简单动规。

【借鉴】这题用滑动窗口也是可以的，同样可以优化到O(N^2)



**T724 寻找数组的中心索引 //python3**

【思路】直接找就完事了。

【注意】优化有风险，优化须谨慎。已经吃过不止一次这个亏了，，，不要随便用大于二分之一求和来判断不存在，因为有可能是负数啊。



**T733 图像渲染 //python3**

【思路】又是连通块的问题，深搜/广搜即可



**T747 至少是其他数字两倍的最大数 //python3**

【思路】如何扫描一遍找到第一大和第二大的数？



**T765 情侣牵手 //python**

【思路】这道题用并查集并不难想，关键是怎样算“连通”？

【借鉴】其实本质上还是贪心的思路，要把右边的奇数位置的配对为偶数位置的对象，虽然证明有点难搞吧。



**T771珠宝和石头(Jewels and Stones) //C++**

这题没什么好说的，有点浪费时间。不需要Hash，直接索引就行了。4ms过了，看别人的代码有0ms过的，快在他用了STL里面的vector，不知道空间会不会省，但时间足够快。



**T785判断二分图 //python3**

【借鉴】染色法（离散课上讲过来着，我给忘了）

【注意】染色法只针对连通图，这题的数据可能图是不连通的（它是从边出发来讲的，所以它可能是个二部图的集合），所以需要遍历完所有的点。

 

**T832** **翻转图像** **//python3**

Python自带list里面就有reverse函数，可以逆序。这道题有个有意思的地方在于Python的机制，如果是C++，一个二重循环必然可以解决；但是Python似乎必须写两次循环。如果直接在对行枚举的循环里面执行取反操作会报错，我也不知道为什么。



**T836 矩阵重叠 //python3**

反向判断，判断怎么样是不重叠就好了。



**T839 相似字符串组 //python3**

【思路】思路就是没有思路，裸并查集（2020年一月，并查集月的最后一天）



**T841 房间和钥匙 //python3**

【思路】水广搜

【注意】我测试了一下python的双向队列，以及直接用列表pop(0)，发现效率差不多？？？我吐了



**T844 比较含退格的字符串 //python3**

【思路】直接模拟

【借鉴】从后向前双指针



**T860 柠檬水找零 //python3**

【思路】贪心+模拟，20拿了也没用，记录5块和10块的数量就行了



**T861 翻转矩阵后的得分//python3**

【借鉴】说来惭愧，这题虽然是简答的贪心，但解法还是借鉴答案的

【思路】亮点：第一行一定全是零，这一定只能借助行翻转来做，为什么？假设第一列全是零，列翻转一次就行，但这实际上和行全部翻转，再把除第一列以外的列再翻转一次是一样的——也就是讲顺序不重要，反正不需要考虑次数，那贪心就好了，每一步都做到最好，一定可以得到全局最好。

步骤划分就很清晰了，一定是先翻转行，让首列最大，然后依次翻转列，让每列的1都多一点（因为权重都一样！）

实际计算不需要模拟这个过程，直接计数就好了，从最后一列倒着往前，权重是2的幂次方。



**T867 转置矩阵 //python3**

【思路】翻译



**T876 链表的中间结点 //python3**

模拟，考查链表的基础操作



**T888 公平的糖果棒交换 //python3**

这题第一遍我还是用数组做的Hash，感觉太捞了，，，之前居然一直这样做hash，又慢空间开销又大，其实直接set把一个列表转化成集合就hash完毕了，，，，这样in查询元素是否存在就成了O(1)的操作。



**T892 三维形体的表面积 //python3**

模拟，先算上下两面，再挨个统计四周，四周只用统计比周围立方体高出的部分就好，剩下的都是被挡住的。



**T914 卡牌分组 //python3**

【思路】本题并不难想到要统计每种卡牌的数量然后计算最大公约数。

【借鉴】但是官方提供的代码就很优秀（略作改动，gcd这种还是可以自己写的），本题主要学习reduce()函数的用法，另外collection的这个Counter也很好用，真香啊：

```python
class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        def gcd(a:int, b:int)->int:
            return a if b==0 else gcd(b,a%b)
        vals = collections.Counter(deck).values()
        return reduce(gcd, vals) >= 2        
```



**T941 有效的山脉数组 //python3**

就这种简单题，其实并不简单，WA了两次，，，，

【注意】数组越界，在分块遍历中太容易被忽视了



**T945 使数组唯一的最小增量 //python3**

【思路1】排序，可以用快排，但是我觉得符合题目本意的应该是计数排序。这本质上是一种贪心的思路，因为数组如何元素各不相同，“熵“最低的情况应该是按原来的顺序排成一个序列（序列中元素各不相同），所以无论是计数排序还是快排都是一样的想法，不过题目既给了元素大小又给了个数，明显更想让做题人用计数排序。

【思路2】哈希，本质上是一种线性的地址映射，额外开一片空间来保存当前的映射情况，比如“1”的位置已经被占了，要向后挪动，开一个数组记录当前挪动到了哪里，这样之后就不用重复搬移。理论上来说这样应该是最快的。



**T952 按公因数计算最大组件大小 //python3**

这题我写了题解，直接粘贴过来了

核心代码其实非常简单,保证人人看得懂：注意p是个质数表

```python
for i in range(len(p)):
    for j in range(1,maxA//p[i]+1):
        if j*p[i] in setA:
            for k in range(j+1,maxA//p[i]+1):
                if k*p[i] in setA:
                    uf.unite(j*p[i],k*p[i])
```


本题用并查集是毫无疑问的（但感觉python非常吃亏，O(NlogN)的算法超过百分之七十也还是慢得离谱）

关键点在于：如何用较低的代价找到两个有公因数的节点？
双重循环是不可能的，那样直接奔着O(N^2)去了。此类问题一般可以从因数入手——我们枚举质因数，然后将具有同一个因子的节点放到并查集的一个集合里就好了。
这样的时间复杂度上确界是NlogN，因为就算枚举的不是因数，最多也就n/1+n/2+n/3+...n/n约莫nlgn的计算量，何况我们枚举的是质因数，复杂度只会更低。

需要注意的细节有以下三点：
①用哈希表判定质因数的某个倍数在不在A中，否则复杂度原地上天
②用筛法找质因数（一个一个判定的话复杂度原地爆炸，还不如不优化），只要找到A数组最大值的一半就可以了（显然，超过一半的不可能是A的两个元素的公共因子）
③添加到并查集的时候注意倍数从1开始（质因数本身可能在A中），但如果质因数自身不在A里面不要误加入了，因为输出的不是分类数量而是最多的分类数目！



作者：longint1024
链接：https://leetcode-cn.com/problems/largest-component-size-by-common-factor/solution/pythonji-qi-zhi-bai-de-xie-fa-by-longint-v96m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**T978 最长湍流子数组 //python3**

【思路】水动规，或者说滑动窗口吧

【注意】相邻元素相等的情形需要特判



**T992 K个不同整数的子数组 //python3**

【借鉴】为了不重不漏，容易想到的是固定左侧元素进行分类，然后我们需要堆问题进行转化，因为如果按左侧元素直接分类，我们的算法会不可避免地变为O(N^2)的还套着哈希的常数，20000的数据直接超时。

转化的思路其实很简单，从一个固定元素开始，最多k-1个元素，之后才是开始，最多k个元素，则不能后移，两者位置差就是这个分类的贡献。由于头指针右移之后，这两个指针都是向右移动的，故而复杂度为O(N)

在实际实现的时候，分别计算最多k-1个元素的数组数目，和k个元素的数组数目，后者减去前者即是答案。



**T995 K连续位的最小翻转次数 //python3**

【借鉴】其实对于这种题不必考虑得太复杂了，，，，

我们考虑从i位开始的翻转，i+1位的翻转是不会影响i位的。所以从左向右看，如果当前位置出现0，那么以当前位置开始的翻转是不可避免的。

【注意】问题在于，你不能真的去翻转，因为那样复杂度奔着N^2去了，本题的数据量需要做到O(N)，维护的队列应当记录翻转的次数。到需要考察的位置，利用翻转的次数考察当前元素是0还是1



**T999 车的可用捕获量（可以一步捕获的棋子数） //python3**

【思路】这种题主要是要读清楚题目，注意是一次的捕获量，所以车只能跑一次。另外注意，python的for循环变量不会停在break的位置，而是停在循环末端的位置。



### T1000~

**T1002 查找常用字符 //python3**

什么叫真正的python啊（战术后仰）

```python
class Solution:
    def commonChars(self, A: List[str]) -> List[str]:
        return list(reduce(lambda x, y: x & y, map(collections.Counter, A)).elements())
```



**T1004 最大连续1的个数Ⅲ //python3**

【思路】滑动窗口，或者双指针，最优问题导致滑窗大小只需要变大即可

【注意】时刻防止越界，特别是刹车操作后步进容易越界



**T1006 笨阶乘 //python3**

【思路】模拟，按题目给的定义分类讨论即可，需要理解它的定义，注意正负号的取向，找到循环节。

【注意】特别需要注意N很小的时候，需要特判

另外，最好不要直接使用输入作为循环变量，特别是需要改变循环终止条件的时候（尽管python对这个不敏感）。

怎么我看到题解都是各种栈啊，这不是个循环体吗，，，





**T1013 将数组分为和相等的三部分 //python3**

【思路】首先求和，然后判断能否被3整除，不能的话直接返回False。然后我就开始了我天秀的想当然操作。其实只要将和分成三份，在累积求和的过程中发现第一份出现，在那之后发现第二份出现（并且不是在末尾出现，防止0,0），就可以了。但是我给它加了个提前判断返回（没有考虑负数），结果这题交了7遍，，，



**T1025 除数博弈 //python3**

【借鉴】偶数返回1，奇数返回0。博弈论果然难，在下跪了

这题用数学归纳法可以归纳出来的，我太懒了（理直气壮）



**T1071 字符串的最大公因子 //python3**

【思路】这题要是按我的想法，从首位开始判断是否相等，一直相等的话分别判周期性，这样就非常麻烦了

【借鉴】如果s1+s2!=s2+s1，直接返回空，如果满足，求最大公约数，返回长度为最大公约数的子串即可。



**T1108 IP地址无效化 //python3**

首先学到的是python类中函数的定义，self是一个类似于C++中类指针this的东西，它的函数返回值的定义是在冒号前完成的，用-><类型>:来表示。

Python的字符串操作和MATLAB非常类似，len()可以直接得到字符串的长度，’+’可以连接两个字符串，可以直接用for i in range(len(s))来遍历字符串位数。



**T1128 等价多米诺骨牌对的数量 //python3**

【思路】非常清晰，哈希+计数，针对特定问题可以设计简单的哈希函数，这题排序相加即可，计数后使用组合数学（太遥远了，忘得差不多了）



**T1160 拼写单词 //python3**

【思路】计数，储存，类似于Hash的思路

【注意】特别在pyhon这类自由度极高的高级语言中，很容易忽视一些底层的问题。比如这道题需要进行数组的拷贝，就会有深拷贝浅拷贝的问题。在C之类的语言中，在写a(list)=b(list)的时候会很明白地想到这是指针，实质上a和b共用一片内存（MATLAB中这样写是默认不公用内存的），但是python在这个问题上更像C，本题我调了几遍之后明白了python列表赋值的机理，也是很有收获的。所以拷贝过程理所当然地成了b=[a[i] for i in range(len(a))]



### 【注意】下面这道题没提交

**T1162 地图分析 //python3**

【注意】写这道题一开始我犯了个迷糊，把平方写成了N^2（MATLAB写法），其实应该是N**2。改过来之后顺手查了下，^表示按位异或。



**T1207 独一无二的出现次数 //python3**

【思路】哈希两次



**T1248 统计优美子数组**

【思路】拿笔画了一下来了思路，这个问题可以拆分成子问题（虽然不能叠加），不过有记忆化的东西在里面。我们只需要统计以每个元素结尾的优美子序列数目，然后相加就可以了。如何统计？记录每两个奇数之间的偶数，以当前元素结尾的优美子序列数目就是前k-1个奇数到前k个奇数之间的偶数个数。

【借鉴】官方题解是相乘的哈，因为连续偶数的解数目是一样的（其实就是把我的方法中相加变成相乘）。但是我认为相乘还要讨论边界条件，不划算的。反正是要判定奇数偶数，不如相加。



**T1423 可获得的最大点数 //python3**

【借鉴】这是周赛186的第二题，重新拿到居然没啥感觉了，，，，主要是需要逆向思维，如果按每次挑一边去判断状态就掉坑里了，，，

所以就是滑动窗口，之前比赛的时候用的时候是前缀和。



**T1498 满足条件的子序列数目 //python3**

【借鉴】为了保证不重不漏，需要界定“必须包含的最小元素”，这里可不能是最大，因为最小的好算。

【学习】主要是了解了bisect库，并学习了下打表的思想，像这道题，打表比快速幂更好。另外，Leetcode的时间计算的是总时间，尽管不超时，但如果小数据用了太多时间也会导致单题排名不好。



**T1579 保证图可完全遍历**

【思路】并查集经典题型

【借鉴】本题代码非常好写，裸并查集，关键在于贪心算法正确性的证明。优先保障公共边的存在是显而易见的，再稍加思考，容易证明的是，我们的算法与遍历的顺序无关，对于这个双向图，最终我们得到的一定是一堆树。所以放心地遍历就好了，然后再分别把并查集拷贝给A和B，用同样的方式去除冗余的边即可。



**T1627 带阈值的图连通性 //python3**

【借鉴】并查集+筛法

【注意】如果不同筛法，那并查集的意义在哪里呢！（好像也是有意义的，总不能多次dfs）



**T1631 最小体力消耗路径 //python3**

【注意】我枯了，坐标映射能写错，，，二维网格映射到数字肯定是x*n+y啊

【借鉴】由于是最大值，贪心方法，从小权边开始加，一直到连通为止。



## Interview-Questions

### 剑指offer

**剑指03 数组中重复的数字**

【思路】模拟，集合的应用/collection的应用



**剑指04 二维数组中的查找**

【思路】二分查找。

【注意】写代码的时候注意力要集中，常见问题不要总是写错，比如讲数组的下标是否越界等等。



**剑指05 替换空格**

【思路】字符串操作

【注意】不要使用split()，多个空格只会识别一个（它只管分割，不会管有几个空格的）



**剑指09 用两个栈实现队列**

【思路】翻转两次，用两个栈，一个在入队时操作，入队的同时压栈。另一个在出队的时候操作，出队的同时把入队栈的东西弹栈（然后再压栈、弹栈），翻转两次就成了先进先出。



**剑指10-1 斐波那契数列**

【思路】通过本题我也有心对比一下直接求和与快速幂的效率区别，毕竟取模是一个挺麻烦的操作。结论是100以内这个数据量用快速幂反而慢出天际，，，

【备注】第70题、第530题和本题一样

```python
class Solution:
    def fib(self, n: int) -> int:
        def multi(x:List[List[int]], y:List[List[int]]) -> List[List[int]]:
            m = len(x)
            n = len(x[0])
            s = len(y[0])
            tmp = [[0 for i in range(s)]for j in range(m)]
            for i in range(m):
                for j in range(n):
                    for k in range(s):
                        tmp[i][k] += x[i][j]*y[j][k] % 1000000007
            return tmp
        fib = [[0,1],[1,1]]
        a = [[0],[1]]
        while n>0:
            if n & 1 == 1:
                a = multi(fib,a)
            n = n//2
            fib = multi(fib,fib)
        return a[0][0] % 1000000007
```



**剑指10-2 青蛙跳台阶问题**

所以这题我就打表了，在类里面直接生成数组，返回self.a[n]即可，95%/100%，这样都没有超过百分之百，前面那百分之五是什么神仙？？？



**剑指11 旋转数组的最小数字**

【借鉴】二分法，将mid与r比较，如果大，在右边；如果小，在左边。优化方法是长度小于10的时候直接暴搜，不过本题数据量太小体现不出来二分法的优越性。



**剑指13 机器人的运动范围**

【注意】本题是一个行走+限制范围的经典模型，问题在于，它要满足两个条件：一是满足限制，二是周围有满足限制的点（可达）

【思路】广度优先搜索，一边广搜一边判断，凡是到达过的点（不管满不满足条件），都标记为到过，不再入队。

【借鉴】虽然这题的数据范围像极了直接暴搜的样子，但是它真的可以递推啊，，，因为只能向右和向下，所以二维递推就好了啊，我怎么忘了这个，看着自己长长的广搜留下了眼泪。



**剑指40 最小的k个数**

【思路1】排序，然后输出，复杂度O(nlogn)，由于样例的特殊性（或者是python自带的sort过于优秀），这个居然会很快？68%/100%

【思路2】优先队列，维护一个包含k个数的优先队列，复杂度O(nlogk)。注意python自带的优先队列只能比更大的，所以输入的时候可以取一个相反数，这样就能得到更小的了。5%/100%，可能我用优先队列用的比较笨，这个反而比思路1来得慢？？？

【思路3】注意到题给描述中有数值范围，很容易想到计数排序的思路，构建一个10001长度的列表，用计数排序的方法统计前k个数，理论复杂度O(n)，空间复杂度O(max(arr))，测试结果52%/100%，这个时间？？这个空间？？这题的测试样例？？

【思路4】快速选择算法（emmmm我懒，暂时没有写这个代码）

【思路5】BFPRT算法，至于为什么叫BFPRT算法，大概（一定）是因为它是由Blum、Floyd、Pratt、Rivest、Tarjan提出的吧。它只能躺在我的收藏夹吃灰了，看了一眼思路，我是不会写的。



**剑指51 数组中的逆序对**

【借鉴】经典算法，用归并排序求解逆序对问题，O(N^2)优化到O(NlogN)



**剑指56-1 数组中数字出现的次数**

【借鉴】经典位运算，首先，如果要找出双元素数组中唯一落单的那个，可以直接异或。如果有两个落单的，可以异或得到两个数的异或值，然后找到出现不同的位置，用与运算将原数组分为两类，一类中包含一个落单的，并且相同的数字一定在同一类中。对两类分别累计异或即可得到想要的两个值。



**剑指59-1 滑动窗口最大值**

【思路】单调队列法，见过更大的世界了肯定不能再暴力了！

【注意】一定注意单调队列中储存的是index！



### 面试题

**面试题01.01 判定字符是否唯一**

【思路】翻译



**面试题 01.06 字符串压缩**

【思路】英语翻译

【注意】仔细读题，考虑”大于“还是”大于等于”



**面试题08.11 硬币**

【借鉴】完全背包

【注意】这题主要的坑点在于它是一个组合问题，其实按照上台阶的思路去做是没问题的，但是上台阶是一个排列问题（先1后2和先2后1是两种方案）。



**面16.03 交点**

【思路】几何题，近年来各种算法题都被各大网站透底透得差不多了，反而是几何题可能直接反映真实修养了。本题我一开始会想到用叉乘判断平行，相交自然是最容易的情况，平行之后判断是否共线，如果不共线返回空，共线需要讨论是否有交点，然后返回重合点中较小的坐标值。

【借鉴】代码比较麻烦，我偷懒没有自己写



**面16.11 跳水板**

循环枚举，注意判重



**面试题17.13 恢复空格**

说起来是“恢复空格”，实际上这是一个给定字符串，寻求查询字典最优匹配的问题。

【借鉴】动规的思路并不难，问题在于如何快速地解决任意长度字符串在字典中查询的问题。直接查询会非常慢，哈希可以有效地节约时间，字典数或使用AC自动机是最优的方式。

【说明】本题收录在Conclusion的“字典树“部分，有详细的解释说明。



**面试题17.16 按摩师**

这是每日一题打卡的时候出现的题目，个人感觉每日一题打卡活动推的题目都是很经典的，像这道题，虽然难度上确实是简单，但是确确实实要懂一些小技巧。

【思路】设定一个数组，记录到当前客户（必须包含当前客户）为止，所能收获的最大总预约时长。由于必须包含该客户，所以一定不能包含上一个客户。故而time[i] = max(time[0:i-2])，顺着递推，在递推的过程中，可以顺便把MAX的计算也做了，所以转移方程为：time[i] = max(MAX,time[i-2])+input[i]，时间复杂度O(n)，递推完成之后顺着扫描一遍找出time数组中最大的那个数就行了。空间复杂度O(n)，果然如我所想，82%/100%，很快。

```python
class Solution:
    def massage(self, nums: List[int]) -> int:
        ans = nums
        MAX = -2147483647
        for i in range(2,len(nums)):
            if ans[i-2]>MAX:
                MAX = ans[i-2]
            ans[i] += MAX
        MAX = 0
        for i in range(len(nums)):
            if ans[i]>MAX:
                MAX = ans[i]
        return MAX
```

【补充】写完思路之后我突然意识到（太蠢了），只需要记录三个数就行了，这题空间复杂度可以到O(1)的。改进的写法更新在T198打家劫舍里了，这两题一模一样。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == []:
            return 0
        if len(nums) == 1:
            return nums[0]
        MAX = max(nums[0], nums[1])
        first, second = nums[0], MAX
        for i in range(2,len(nums)):
            if first + nums[i] > MAX:
                MAX = first + nums[i]
            first = second
            second = MAX
        return MAX
```

【借鉴】整个写完之后我看了下别人的想法，发现确实没有必要设置“一定包含”，这样的话dp[i]=max(dp[i-2]+nums[i],dp[i-1])就完事了。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == []:
            return 0
        if len(nums) == 1:
            return nums[0]
        MAX = max(nums[0], nums[1])
        first, second = nums[0], MAX
        for i in range(2,len(nums)):
            MAX = max(first+nums[i], second)
            first = second
            second = MAX
        return MAX
```





## Weekly-Contest

### 179  2020/3/8

本周的比赛是在美服参加的，对应国服T5353和T5354（后来发现国服更新的慢，确实是美服的题号）

score: 7, time: 59:33, rank: 3051 / 6242

**T1374. Generate a String With Characters That Have Odd Counts //python3**

生成一个字符串，模拟题

**T1375. Bulb Switcher III //python3**

简单模拟，这题我用set()去判断的，做了一点优化，没有超时也是很神奇

后来看别人的代码，直接判断第i次的时候最大值是不是i就行了，多简单

**回顾**

本次周赛题并不困难，第三题就是广度优先遍历一下树就可以了。但是我11点多才开始做这个比赛，又蠢到把BFS写错了= =。



### 180  2020/3/15

本周比赛回到国服进行，预计之后应该都会在国服参赛了

score: 11, time: 58:15+5min=1:03:15, rank: 747 / 3714 || 2930 / 10047

**T1380 矩阵中的幸运数 //python3**

其实我感觉类似这种题，不用过多地去想如何优化，直接翻译就好了，一般不会超时

**T1381 设计一个支持增量操作的栈 //python3**

本题需要熟悉类和对象的基本操作，另外用数组实现一下基本数据类型：栈。感觉这题还挺有意思。

【注意】类的构造函数，每次提交需要注意刷新相关变量。已经不止一次因为这个丢分了，它的测试运行是会保留上一个输入数据的类中变量的。

```python
class CustomStack:
    stack = []
    MAX = 0
    
    def __init__(self, maxSize: int):
        self.MAX = maxSize
        self.stack = []

    def push(self, x: int) -> None:
        if len(self.stack)<self.MAX:
            self.stack.append(x)

    def pop(self) -> int:
        if self.stack == []:
            return -1
        else:
            ans = self.stack[len(self.stack)-1]
            del self.stack[len(self.stack)-1]
            return ans

    def increment(self, k: int, val: int) -> None:
        if len(self.stack)<k:
            for i in range(len(self.stack)):
                self.stack[i] += val
        else:
            for i in range(k):
                self.stack[i]+=val


# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

**T1382 将二叉搜索树变平衡 //python3**

【思路】一开始看到这道题我是很慌的，因为AVL树的那些操作我基本都忘光了。但是静下来思考，发现并不需要复杂的数据结构知识。因为题目给的就已经是二叉搜索树了，所以中序遍历即可得到一个包含树上所有元素的有序数组。然后把这个有序数组递归生成平衡树即可。

【补充】在具体实现的时候，参考数据范围，我没有做中序遍历（图省事儿），直接把所有元素放出来做了一遍排序，这样时间效率肯定大打折扣，但是不会超时。

**T1383 最大的团队表现值 //python3**

【思路】拿到这道题我想了很多，最先排除的是贪心（，，，），想了很长时间的动态规划，但是发现本题似乎并不具备最优子结构。最终想到，如果枚举最小的效率，然后只需要从效率更高的人中找k-1（如果不足k-1个，有多少来多少）个速度最快的就行了。所以建立一个包含index、速度和效率的列表，以速度为关键字排序，再以效率为关键字排序（sort默认的是，放在首位的是排序主关键字）。但是这样会存在很大的问题：为了保证当前枚举的人是计算中效率最低的（必须包括且必须是效率最低），需要依次删除枚举的人，并对剩下的人进行重新排序。这个就非常麻烦了，时间效率直指N^2，结果可想而知，超时（不过过了51个点，最后两个点超时）

```python
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        Mod = 10**9+7
        sl, el = [], []
        for i in range(n):
            el.append([efficiency[i],speed[i],i])
            sl.append([speed[i],efficiency[i],i])
        el.sort()
        sl.sort()
        MAX = 0
        for i in range(n):
            n = len(sl)
            ee, ss, ii = el[i][0], el[i][1], el[i][2]
            if n>k:
                sss = sl[n-k:n]
            else:
                sss = sl
            summ = 0
            if [ss,ee,ii] in sss:
                for j in range(len(sss)):
                    summ+=sss[j][0]
            else:
                sss = sss[1:len(sss)]
                summ += ss
                for j in range(len(sss)):
                    summ += sss[j][0]
            if summ*ee>MAX:
                MAX = summ*ee
            sl.remove([ss,ee,ii])
        return MAX% Mod
```

【借鉴】可以维护一个优先队列，来取出前k个。注意，我借鉴的思路是倒着推的，为什么倒着推？因为，按照我的思路，最小的效率必须被包含（正着推的话）。但是如何倒着推，最小的效率不需要一定包含：因为只有在最小效率的speed大到前k位的时候它才被包含，如果没有大到前k位，之前肯定计算出过更大的结果。下面把别人的代码贴上，写得非常漂亮。

```python
from queue import PriorityQueue
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        items = [(speed[i], efficiency[i]) for i in range(n)]
        items.sort(key=lambda item:item[1], reverse=True)
        add_sum = 0
        pq = PriorityQueue()
        res = 0
        for i in range(n):
            pq.put(items[i][0])
            add_sum += items[i][0]
            if pq.qsize() > k:
                add_sum -= pq.get()
            val = add_sum * items[i][1]
            if val > res:
                res = val
        return res % (10 ** 9 + 7)
```



### 181  2020/3/22

本周比赛在国服进行，艰难AK

score: 18, time: 1:08:23+5min=1:13:23, rank: 128 / 4148 || 495 / 10930

**T1389 按既定顺序创建目标数组**

本题考查对各语言标准库函数的应用，python3的话直接array.insert(index,num)即可。

**T1390 四因数**

本题是数学题，考查埃拉托斯特尼筛法的变形。如果一个数n要有正好四个因数，那么它首先不能是完全平方数；其次是在2~sqrt(n)之间只能有一个数可以被其整除。对本题而言，使用筛法检测的时间复杂度为O(nsqrt(max(num)))，对照数据范围可知筛法完全可以轻松应对。

**T1391 检测网络中是否存在有效路径**

本题的灵感可能来自于《太阁立志传5》的灌溉训练。

【思路】BFS，由于每个“块”只有两个方向通向下一个块，所以这是一棵二叉树，宽度优先遍历它即可很快得到其是否存在路径。我的思路是建立一个邻接矩阵来判定类型为index1和index2的两块是否可以连通，剩下的思路就如何走迷宫。

**T1392 最长快乐前缀**

【借鉴】

本题不是我自己做出来的。拿到这道题我首先想到了KMP算法，本身KMP算法简化一下就是前后缀匹配，而正好网上有KMP算法的代码，我把C++改成了python再小做修改就过了（据说python暴力也能过？）。

```python
class Solution:
    def longestPrefix(self, s: str) -> str:
        next = [0 for i in range(len(s)+1)]
        def getnext(s:str) ->None:
            n = len(s)
            next[0] = 0
            i = 0
            for j in range(1,len(s)):
                while(s[i]!=s[j] and i>0):
                    i = next[i-1]
                if (s[i]==s[j]):
                    i += 1
                    next[j] = i
                else:
                    next[j] = 0
        getnext(s)
        return s[0:next[len(s)-1]]
```



### 182  2020/3/29

本周比赛提前放弃了，最后一题想了半个小时，并没有思路。

score: 12, time:22:08, rank: 147 / 3910 || 667 / 11694

**T1394 找出数组中的幸运数**

【思路】统计频次，注意找不到的情况即可

**T1395 统计作战单位**

【思路】暴力枚举，O(N^3)，看数据范围是可以过的

**T1396 设计地铁系统**

【思路】纯模拟，记录对应ID的出入站时间地点，对应检索即可

**T1397 找到所有的好字符串**

【想法】个人感觉这肯定是个数学题，有组合数学的味道，字典序大于s2小于s1的字符串数量很容易统计，关键在于如何计算不包含evil字符串的数量？目前想法是反过来计算包含evil的数量，这样的话就要从失配位置开始，逐个统计后插，用容斥原理补上多去掉的数目，但是想想都很复杂啊，，，如果evil太长了，容斥原理公式会很麻烦。

【借鉴】

此处参考别人的代码：



### 184  2020/4/12

上周玩游戏去了没有参加，本周参赛主要是为了下周六的2020年力扣杯春季全国程序设计大赛做准备。

本周题目比较简单，虽然我上来第一题就罚了时，中途去了次WC，但还是一个小时AK了。

score: 19, time: 0:59:04+5min = 1:04:04, rank: 232 / 3846 || 1013 / 13661

**T1408 数组中的字符串匹配**

【思路】枚举

【注意】这题是有坑的！虽然题目中保证给出的字符串没有重复的，但是如果暴力枚举的时候不注意break，会导致结果中有重复项，比如{od,odd,oddd}，如果不发现子串后立刻break，就会输出两边od！因为这个被罚时多亏啊。

**T1409 查询带键的排列**

【思路】模拟

【注意】如何将一个元素改变位置，其他元素位置相对不变？

**T1410 HTML实体解析器**

【思路】字符串操作

【注意】打表需谨慎，一定要好好检查表打得对不对

**T1411 给N乘3的网格图涂色的方案数**

【思路】递推

【解析】本题把n=1的12种状态给出来了，这无疑直接提供了思路，使得题目难度大大降低。不然说实话这题还挺麻烦的，要自己去分析状态的转移。

【借鉴】个人感觉，如果没有做过类似的题目，上面这种思路是最容易想到的，就是直接分析状态转移然后递推。本题借鉴大佬的思路，可以分为abc和aba两种情况，每种的初始状态都是6种，然后abc可以衍生bca、cab两种和bab、bcb两种，aba可以衍生bac、cab两种和bab、bcb、cac三种，然后两项递推求和即可，时间复杂度会低不少。



### 185  2020/4/19

本周是周赛+字节跳动春招，相对来讲参赛人员感觉都认真了很多。在大家普遍认真对待的情况下就把目前我的真实水平反映出来了。主要问题有以下几点：

1. 心态不稳，慌得一批。习惯了前两题不费劲秒杀，出了问题或者WA就开始手足无措。远远做不到“握剑而起，心必如常”。
2. 思路不清晰，基本靠直觉，没有清晰的解题套路和想法，不会归类
3. 部分专题掌握得太差，各种动规还有特别是哈希map基本是空白，有畏惧感
4. 代码能力不够，python的很多基本用法没掌握，写起来跟C一样还没有C严谨
5. 即使有思路，码的过程中也做不到按思路来，码了二十行就忘了自己要干嘛
6. 细节把握不够，慌，认为周赛就不需要把握细节（这次把大小写弄错那个WA就很要命，辛亏题目还给出了错误细节，不然可能很难找到），分析复杂度也不到位。

score: 12, time: 0:51:04+2*5min = 1:01:04, rank: 436 / 5002 || 1795 / 14208

**T1416 重新格式化字符串**

【思路】强调明确、简洁的思路

怎么样算明确简洁？

分开统计数字和字母，如果数量差别绝对值大于1返回-1

如果数字和字母一样多，for长度，插数字插字母

如果数字比字母长一个，插数字，for字母长度，插字母插数字（+1）

如果字母比数字长一个，插字母，for数字长度，插数字插字母（+1）

其实非常简单，按这个思路写不可能写10分钟的。

**T1417 点菜展示表**

【思路】这题确实恶心人，恶心人的点在于刷力扣时间长了之后，控制输入输出格式的水平确实有所下降

【注意】细节，大小写

**T1418 数青蛙**

【思路】俄罗斯方块，这其实就是个模拟

【注意】还是注意思路的清晰，怎么样叫稳呢，思路清晰，比赛的时候加满一次croak我忘了减掉。



最后一题是三维动规。唉。



### 186  2020/4/26

score: 18, time: 0:57:51+3*5min = 1:12:51, rank: 107 / 3107 || 488 / 11684

**T1422 分割字符串的最大得分**

【思路】比赛的时候是N^2枚举的，现在想想可以前缀和优化到N的

**T1423 可获得的最大点数**

【思路】这次的出题人特别喜欢前缀和啊，这题又是前缀和，O(n+k)

**T1424 对角线遍历二**

【思路】一开始我是想着模拟来着，不过这题吧，它都是左下到右上的，那简单了，i+j为主关键字，j为次关键字，排序就好了。

**T1425 带限制的子序列和**

【思路】经典DP最大连续子序列和的改动版本

【借鉴】子问题就是如何求滑动窗口最大值，也就是【LeetCodeT239】，单调队列法。



### 197 2020/7/12

本周的题有点不按套路出牌，但还是能很好地考查基本功和数学功底的

score: 14, time: 1:29:56+3*5min = 1:44:56, rank: 211 / 5274 || 853 / 13984

**T1512 好数对的数目**

【思路】模拟

**T1513 仅含1的子串数**

【思路】找到每一段最长的仅含1的子串，统计它们分别贡献的子串数目就好了

**T1514 概率最大的路径**

【思路】朴素Dijkstra算法，具体描述写在Conclusion中了

**T1515 服务中心的最佳位置**

【思路】求到所有点欧氏距离之和最短的凸优化问题，这个问题已经是基本的模板了，梯度下降、模拟退火经典算法。当然出现在竞赛中，三分套三分是最好最快的解法。



### 198 2020/7/19

微软的题目质量还是很高的，美中不足的是最后一题数据太弱，咋写都能过，导致我本周的名次高得不正常，不能反映真实水平。

score: 15, time: 1:13:53+1*5min = 1:28:53, rank: 126 / 5779 || 293 / 15152

**T1518 换酒问题**

【思路】模拟，关键在于思路清晰头脑清醒，分别设定变量表示酒瓶、酒，循环即可

**T1519 子树中标签相同的节点数**

【思路】本题很多解法给的是深搜，但我觉得， 层序遍历即可。从最底层开始，统计每个节点的子树含有26个字母子节点的个数，一层层推上去就好了

【注意】0一定是根节点，在做关于树的问题时一定要注意有没有规定根节点。

**T1520 最多的不重叠子字符串**

【借鉴】本题我没做出来，究其原因是初始化没有做好。容易想到，应该统计每个字符在字符串中的起止位置。然后，对26个字母的起止位置，还要结合其中夹了哪些字符，因为比如说ddaaffaf，尽管a的起止位置统计完毕，但从第一个a到最后一个a并不能作为一个答案，因为其中夹了f，而f并不都包含在其中。所以这一步应该对起止位置中夹的字母做一个统计，根据这些字母的起止位置拓展当前的起止位置，直到不能再向外扩为止。

之后，本题就变成了一个线段覆盖问题，用贪心法即可。

**T1521 找到最接近目标值的函数值**

【思考】本题啊数据太弱了，我写了个错误的动规也AC了

```python
#t1521官方Solution
class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        ans = abs(arr[0] - target)
        valid = {arr[0]}
        for num in arr:
            valid = {x & num for x in valid} | {num}
            ans = min(ans, min(abs(x - target) for x in valid))
        return ans
```



### 200 2020/8/2

本次周赛名次不理想，究其原因有以下几点：

①7月每日一题打卡不断，但是很多题目没有仔细研究，囫囵吞枣；②竞技状态明显下滑，智齿手术后人明显变懒，思维活跃程度下降；③思路越来越直，抽象能力下降；④对很多基本语法的应用依然不熟悉

score:18, time:1:15:15+2*5min = 1:25:15, rank: 317 / 5474 || 835 / 15382

**T1534 统计好三元组**

【思路】暴力枚举O(N^3)，本题正常发挥

【改进】双层循环时可以剪枝，外两层循环i和j条件不满足时不开启第三重循环

**T1535 找出数组游戏的赢家**

【思路】模拟，按照题目描述的过程去模拟游戏的过程。本题显然做太慢了

【借鉴】完全没必要，本题处理的唯一亮点是把k缩小了。实际上，维持一个“擂主”的位置即可，按顺序向后遍历，如果出现了能站住k轮以上的“擂主”就留下，或者遍历完了则直接返回当前的“擂主”。

**T1536 排布二进制网格的最少交换次数**

【思路】一眼排序，本题做得还算可以，思路正常。关键字是从右向左连续零的数量。排序过程中的规则是贪心，即连续零越多且越靠上的行优先向上调度。如此，冒泡排序即可。如果出现当前位置无法满足的行，返回-1

**T1537 最大得分**

【思路】从7月的历练（动态规划月）中走出来的我满脑子动态规划，所以这题一看满足子结构和无后效性就上动规了，做得无比复杂。思路是首先用双指针的方法找到两个数列之间重合的位置，并用Index数组分别记录，如果没有重合位置的元素记为-1。为了确保dp[i,~] = max(dp[i,0],dp[index[i],0])中引用的部分已经被计算，继续使用双指针，从比较小的元素算起，到相等的元素时计算两遍。类似归并排序，做完之后需要对没有处理完的一列单独处理。最终返回的是dp[n1]与dp[n2]中较大的值对M取余的结果。

【借鉴】本质上这题就是双指针啊，相等的元素可以把两列分为不同的截断，每一段取较大的和即可。它强调的是一个整体性的思路，而不是考虑单个元素。



### 201 2020/8/9

本周周赛表现不佳，究其原因，首先是最近学习态度并不端正，思维速度明显下降。其次最近刷题较少，表现得手生。最后身体状况欠佳。

score:14, time:49:15+0*5min = 49:15, rank: 306 / 5614 || 965 / 15616

**T1544 整理字符串**

【思路】本题数据规模较小，因而暴力循环就可以通过。实现的时候注意关于大小写的判断。python很方便，upper()或者lower()的内置函数就可以实现

【借鉴】如果数据规模较大，用栈来实现会比较明智。

**T1545 找出第N个二进制字符串的第K位**

【思路】暴力模拟，我计算了一下觉得不会超时，但实际表现得非常危险，在超时的边缘。

【借鉴】这题最明智的思路应该是递归。像这种问题，递归显然是最佳解法，递推反而没有办法解决。

**T1546 和为目标值的最大数目不重叠非空子数组数目**

【思路】比赛的时候我当然想到了前缀和，但是却忘了哈希，这题总是超时，搞得心态十分爆炸。

【借鉴】和为目标值，那只要哈希前缀和，利用S2-S1=target可以得到S1=S2-target，储存S到集合中，哈希判断存在即可ans+1。为了保证不重叠，判断存在后将集合清空，从该位置接着开始求前缀和即可。

**T1547 切棍子的最小成本**

【思路】本题和Conclusion中的切气球其实很相似，都是区间型动态规划，说起来都有一点记忆化搜索的味道。区间DP首先要考虑要不要扩充区间边界，然后要注意枚举的顺序。



### 202 2020/8/16

本周表现非常糟糕，对较为灵活的题目，明显表现出基础较为糟糕的一面。第三题的二分不会做是非常不应该的，最后一题只能想到裸递归也确实非常辣鸡。

score:7, time:5:38+0*5min = 5:38, rank: 835 / 4987 || 2541 / 14373

**T1550 存在三个连续奇数的数组**

【思路】模拟，可以优化常数，我优化过常数减了一半之后反而变慢了，雾

**T1551 使数组中所有元素相等的最小操作数**

【思路】最终结果是显然的，那么直接做差就好了。当然也可以直接推公式

**T1552 两球之间的磁力**

【借鉴】二分查找

**T1553 吃掉N个橘子的最少天数**

【思考】本题我只能想到简单递归，中间想过向进制转换上靠，但是结果都失败了

【借鉴】本题关键要优化的东西在f(n-1)这个令人厌烦的东西，如果一直带着它，计算成本必然非常高昂。可以证明，对任意一个数，如果-2再除2，不如除2再减一。如果-3再除3，不如除3再减1。如果减2再除3呢？这还是很有可能的。所以，减一这种情况根本没有必要讨论，要比较的结果只是除2/除3再加上模2/模3的结果，其中取较小的数字，再加一即可。

【优化】在上述这种情况下，依然很容易超时，因为还是会做大量的重复计算。此时哈希的优化就显得非常重要。



### 226 2021/1/31

新的一年，关于本次周赛就不多加点评了，许久未曾参赛。

score:12, time:1:05:59+2*5min = 1:15:59, rank: 675/4033||2020/11433

**T1742 盒子中小球的最大数量**

【思路】放在这里当然是纯模拟

【借鉴】这题是可以用数位DP的，也可以找找规律：毕竟不进位的话，就是加1呀。

**T1743 从相邻元素对还原数组**

【思路】这题不需要哈希，本身数字范围有限制很容易做映射。另外，“回头路”只可能是跨一个节点回头，所以检查前驱节点就知道有没有形成环路了。

**T1744 你能在你最喜欢的那天吃到你最喜欢的糖果吗？**

【思路】又是模拟，可以说是贪心的思路吧，加一个前缀和的预处理技巧

**T1745 回文串分割 Ⅳ **

【借鉴】我一开始是直接三重循环N三方的，，，理论上来讲，常规数据集不至于超时，但是比赛的题目必然设置了卡时间的点让你的N三方掉到坑里去。然后就修改了做法，把中间的的串改成中心拓展，这样倒是只需要O(n)，但是两边的判断还是需要O(n^2)，这样中心点一动又奔着O(N^3)去了，，，，

本题的动规思路并不复杂，了解到可以动规之后直接就推出来了，属于最基础的一类动规。



### 229 2021/2/21

每况愈下，参赛的自信已经被完全摧毁了，两道水动规都做不出来。。。。

score:12, time:10:46+0*5min = 10:46, rank: 797/3483||2375/11178

**T1768 交替合并字符串**

【思路】交替合并，注意讨论哪个更长就OK

**T1769 移动所有球到每个盒子所需的最小操作数**

【思路】对每个位置，枚举其它位置的差累计求和嘛，，，



### d49 2021/4/3

还凑合，我现在已经完全想明白为什么最后一题贪心的思路不对了（比赛的时候已经意识到了，其实意识到的时候就该立刻换思路）

score:12, time:23:44+0*5min = 23:44, rank: 111/3193||303/9082

**T1812 判断国际象棋棋盘中一个格子的颜色**

【思路】由于棋盘很小，可以打表

**T1813 句子相似性 Ⅲ**

【思路】这道题有一点点麻烦，首先要注意题目没有指定顺序，所以先预处理一下，保证是S1包含S2。然后从S2的两头抽取单词，能在S1的两头找到就往中间靠拢，能碰头就是相似的，不能碰头就GG

**T1814 统计一个数组中好对子的数目**

【思路】预处理+握手



### 235 2021/4/4

我觉着你真的需要好好反思一下。这次周赛所犯的错误，简直匪夷所思。在不好好睡觉的情况下，早上的表现是灾难性的，人都变傻了。





## LCP

### 2020-spring-solo

score: 20/30, time: 1:24:34+5*5min = 1:49:34, rank: 238/4093(9293)

**LCP 06 拿硬币**

【思路】模拟

**LCP 07  传递信息**

【思路】模拟，图的连通性问题

【借鉴】看到一个有趣的思路是求可达矩阵，01邻接矩阵的N次幂表示可达路径条数，挺有意思的，可以用快速幂优化，如果k很大用这个确实非常赞

**LCP 08 剧情触发时间**

【思路】我的思路是模拟，累加时间，然后累加资源，搜索事件，触发事件。然后超时了，做了一下优化，改成将事件按文明等级排序，从上次失配位置-k开始找下一次事件。

【借鉴】这题充分证明了我基础不扎实，陷入了模拟的深坑无法自拔。既然按时间累加的资源的是一个有序数列，为什么不能反过来在这个时间序列中查找事件呢？

要知道，这不是真的让你玩游戏，是事后分析事件，不需要实时播报。

**LCP 09 最小跳跃次数**

【思路】广搜+剪枝。显然广搜会超时

1. 剪枝思路一：枚举到过的点，到过的点不再入队。因为这会形成环路，必然使得最终的步数增大，是无意义解。超时
2. 剪枝思路二：对到过的点进行Hash，将查询是否到过降到O(1)，依然超时
3. 剪枝思路三：既然每次到一个点，下次就要到左边所有点，那直接记录这个点为当前到过最大值就好，小于这个最大值的点都不要再进了。通过

【借鉴】本题有动规思路

**最后一题是树状动规**  不会，难受



### 2020-spring-team

score: 16/42, time: 2:03:04, rank: 77/1066(2702)

**LCP 11 期望个数统计**

【思路】概率论问题，全排列后重叠的期望为1，所以是求不重复元素个数，对python来讲就是转换为set求容量

**LCP 15 游乐园的迷宫**

【借鉴】贪心，可以从凸包上的一个点出发，如果下一步是L，就让所有的点都在当前连线的左边（排序即可，这里是角排序）；如果下一步是R，就让所有点都在当前连线的右边。这样每一次的选择容量都是最大的。

【思路】比赛的时候我自己写的是回溯，暴搜也能通过这道题的数据。



### 2020-autumn-solo



## Postscript

 LeetCode可能确实是网络上最简单的成年人oj，难度确实和ICPC什么的没法比，但是我始终觉得：把简单的东西做好就是不简单。在实际工作当中，可能连LeetCode-hard级别的问题也是很少遇到的，因而从功利的角度来说，LeetCode也许是工科狗的最好选择——毕竟大部分人这辈子都用不到AC自动机或者树状DP，甚至连FFT也不可能自己动手写一遍。

不管怎么说，闲暇时光写一写，总比开把游戏来得实惠些（后记：写完这段这人就应该是打游戏去了）。